# -*- coding: utf-8 -*-
"""Resolution and Sharpness of Images

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dt-SLffFv1G7dlGy5o08Gmy8g_18ySrE

# Resolution and Sharpness of Images
From Damian Howe and Haarsha Krishna

## Formatting Data and Classes
"""

import matplotlib.pyplot as plt
import pylab as pylab
import numpy as np
import cv2 as cv2
import math as math

from PIL import Image, ImageOps
from scipy import interpolate
from scipy.fft import fft
from enum import Enum
from dataclasses import dataclass
from pathlib import Path

@dataclass
class cSet:
  x: np.ndarray # storing indexes as a numpy array
  y: np.ndarray # storing values as a numpy array

@dataclass
class cESF:
  rawESF: cSet # raw ESF data as numpy arrays
  interpESF: cSet # interpolated ESF data as numpy arrays
  threshold: float # threshold used for ESF/MTF
  width: float # pixel transition size
  angle: float # slant angle (deg)
  edgePoly: np.ndarray # polynomial of slant

@dataclass
class cMTF:
  x: np.ndarray # array for indexes
  y: np.ndarray # array for values
  mtfAtNyquist: float # MTF value at sampling speed limit (Nyquist Freq)
  width: float # pixel transition size

@dataclass
class Verbosity(Enum): # output types/level of output
  NONE = 0 # none
  BRIEF = 1 # text
  DETAIL = 2 # graphical

"""## Image importing Functions"""

class Transform:

  @staticmethod
  def LoadImg(file):
    img = Image.open(file)
    if img.mode in {'I;16','I;16L','I;16B','I;16N'}: # need correct format 16-bit unsigned integer pixel
        gsimg = img
    else:
        gsimg = img.convert('L') # converts to 8 bit pixels in greyscale
    return gsimg

  @staticmethod
  def Arrayify(img):
    if img.mode in {'I;16','I;16L','I;16B','I;16N'}:
      arr = np.asarray(img, dtype = np.double)/65535 # normalizing
    else:
      arr = np.asarray(img, dtype = np.double)/255 # also normalizing
    return arr # returns normalized array of img data

  @staticmethod
  def Imagify(Arr):
    img = Image.fromarray(Arr*255, mode='L')
    return img

  @staticmethod
  def Orientify(Arr):
    tl = np.average(Arr[0:2, 0:2])
    tr = np.average(Arr[0:2, -3:-1])
    bl = np.average(Arr[-3:-1, 0:2])
    br = np.average(Arr[-3:-1, -3:-1])

    corners = [tl, tr, bl, br]
    cornerIndexes = np.argsort(corners)

    if (cornerIndexes[0] + cornerIndexes[1]) == 1:
      pass
    elif(cornerIndexes[0] + cornerIndexes[1]) == 5:
      Arr = np.flip(Arr, axis=0)
    elif(cornerIndexes[0] + cornerIndexes[1]) == 2:
      Arr = np.transpose(Arr)
    elif(cornerIndexes[0] + cornerIndexes[1]) == 4:
      Arr = np.flip(np.transpose(Arr), axis=0)

    return Arr

"""## MTF Functions

"""

class MTF:
  # distances = microns/pixels away from the slant edge
  # values = array of brightnesses
  # head = top limit
  # tail = bottom limit
  @staticmethod
  def crop(values, distances, head, tail):
    isIncrementing = True
    if distances[0] > distances[-1]:
      isIncrementing = False
      distances = -distances
      dummy = -tail
      tail = -head
      head = dummy

    hindex = (np.where(distances < head)[0])
    tindex = (np.where(distances > tail)[0])

    if hindex.size < 2:
        h = 0
    else:
        h = np.amax(hindex)
    if tindex.size == 0:
        t = distances.size
    else:
        t = np.amin(tindex)

    if isIncrementing == False:
        distances = -distances

    return cSet(distances[h:t], values[h:t])

  @staticmethod
  def GetESF(Arr, edgePoly, verbose = Verbosity.NONE):
    Y = Arr.shape[0]
    X = Arr.shape[1]

    values = np.reshape(Arr, X*Y)

    distance = np.zeros((Y,X))
    column = np.arange(0,X) + 0.5
    for i in range(Y):
      distance[i,:] = (edgePoly[0]*column - (i+0.5) + edgePoly[1]) / np.sqrt(edgePoly[0]*edgePoly[0] + 1)

    distances = np.reshape(distance, X*Y)
    indexes = np.argsort(distances)

    sign = 1
    if np.average(values[indexes[:10]]) > np.average(values[indexes[-10:]]):
      sign = -1

    values = values[indexes]
    distances = sign*distances[indexes]

    if (distances[0] > distances[-1]):
      distances = np.flip(distances)
      values = np.flip(values)

    if (verbose == Verbosity.BRIEF):
      print(f"Raw ESF [done] (Distance from {0:2.2f} to {1:2.2f})".format(sign*distances[0], sign*distances[-1]))

    elif (verbose == Verbosity.DETAIL):
      x = [0, np.size(Arr,1)-1]
      y = np.polyval(edgePoly, x)

      fig = pylab.gcf()
      fig.canvas.manager.set_window_title('Raw ESF')
      (ax1, ax2) = plt.subplots(2)
      ax1.imshow(Arr, cmap = 'gray')
      ax1.plot(x, y, color = 'r')
      ax2.plot(distances, values)
      plt.show()
      plt.show(block = False)

    return cSet(distances, values)

  @staticmethod
  def GetESF_crop(Arr, verbose = Verbosity.NONE):
    imgArr = Transform.Orientify(Arr)
    edgeImg = cv2.Canny(np.uint8(imgArr*255), 40, 90, L2gradient = True)

    line = np.argwhere(edgeImg == 255)
    edgePoly = np.polyfit(line[:,1], line[:,0], 1)
    angle = math.degrees(math.atan(-edgePoly[0]))

    finalEdgePoly = edgePoly.copy()
    if angle>0:
      imgArr = np.flip(imgArr, axis = 1)
      finalEdgePoly[1] = np.polyval(edgePoly, np.size(imgArr, 1)-1)
      finalEdgePoly[0] = -edgePoly[0]

    esf = MTF.GetESF(imgArr, finalEdgePoly, Verbosity.BRIEF)

    esf_Values = esf.y
    esf_Distances = esf.x

    max = np.amax(esf_Values)
    min = np.amin(esf_Values)

    threshold = (max - min) * 0.1

    head = np.amax(esf_Distances[(np.where(esf_Values < min + threshold))[0]])
    tail = np.amin(esf_Distances[(np.where(esf_Values > max - threshold))[0]])

    width = abs(head-tail)

    esfRaw = MTF.crop(esf_Values, esf_Distances, head - 1.2*width, tail + 1.2*width)

    qs = np.linspace(0,1,20)[1:-1]
    knots = np.quantile(esfRaw.x, qs)
    tck = interpolate.splrep(esfRaw.x, esfRaw.y, t=knots, k=3)
    ysmooth = interpolate.splev(esfRaw.x, tck)

    InterpDistances = np.linspace(esfRaw.x[0], esfRaw.x[-1], 500)
    InterpValues = np.interp(InterpDistances, esfRaw.x, ysmooth)

    esfInterp = cSet(InterpDistances, InterpValues)

    if (verbose == Verbosity.BRIEF):
        print(f"ESF Crop [done] (Distance from {0:2.2f} to {1:2.2f})".format(esfRaw.x[0], esfRaw.x[-1]))

    elif (verbose == Verbosity.DETAIL):
        x = [0, np.size(imgArr,1)-1]
        y = np.polyval(finalEdgePoly, x)

        fig = pylab.gcf()
        fig.canvas.manager.set_window_title('ESF Crop')
        (ax1, ax2) = plt.subplots(2)
        ax1.imshow(imgArr, cmap='gray', vmin=0.0, vmax=1.0)
        ax1.plot(x, y, color='red')
        ax2.plot(esfRaw.x, esfRaw.y,InterpDistances,InterpValues)
        plt.show(block=False)
        plt.show()

    return cESF(esfRaw, esfInterp, threshold, width, angle, edgePoly)

  @staticmethod
  def Simplify_ESF(ESF, verbose=Verbosity.NONE):

    res = np.unique(ESF.x, return_index=True, return_counts=True)

    indexes = res[1]
    counts = res[2]
    sz = np.size(res[0])

    distances = ESF.x[indexes]
    values = np.zeros(sz, dtype=np.float64)

    for i in range(sz):
        values[i] = np.sum(ESF.y[indexes[i]:indexes[i]+counts[i]])/counts[i]

    if (verbose == Verbosity.BRIEF):
        print("ESF Simplification [done] (Size from {0:d} to {1:d})".format(np.size(ESF.x), np.size(distances)))

    elif (verbose == Verbosity.DETAIL):
        fig = pylab.gcf()
        fig.canvas.manager.set_window_title("ESF Simplification (Size from {0:d} to {1:d})".format(np.size(ESF.x), np.size(distances)))
        (ax1, ax2) = plt.subplots(2)
        ax1.plot(ESF.x, ESF.y)
        ax2.plot(distances, values)
        plt.show(block=False)
        plt.show()

    return cSet(distances, values)

  @staticmethod
  def GetLSF(ESF, normalize = True, verbose = Verbosity.NONE):
    lsfDividend = np.diff(ESF.y)
    lsfDivisor = np.diff(ESF.x)

    lsfValues = np.divide(lsfDividend, lsfDivisor)
    lsfDistances = ESF.x[0:-1]

    if normalize:
      lsfValues = lsfValues / (max(lsfValues))

    if (verbose == Verbosity.BRIEF):
      print(f"MTF [done]")

    elif (verbose == Verbosity.DETAIL):
      fig = pylab.gcf()
      fig.canvas.manager.set_window_title("LSF")
      (ax1) = plt.subplots(1)
      ax1.plot(lsfDistances, lsfValues)
      plt.show(block=False)
      plt.show()
    return cSet(lsfDistances, lsfValues)

  @staticmethod
  def GetMTF(LSF, fraction, verbose = Verbosity.NONE):
    N = np.size(LSF.x)
    px = N/(LSF.x[-1]- LSF.x[0])
    values = 1/np.sum(LSF.y)*abs(fft(LSF.y))
    distances = np.arange(0,N)/N*px

    interpDistances = np.linspace(0,1,50)
    interp = interpolate.interp1d(distances, values, kind='cubic')
    interpValues = interp(interpDistances)
    valueAtNyquist = interpValues[25]*100

    target = fraction
    crossing_idx = np.where(interpValues <= target)[0]
    if len(crossing_idx) > 0:
        cutoff_freq = interpDistances[crossing_idx[0]]
    else:
        cutoff_freq = None
    
    if (verbose == Verbosity.BRIEF):
      print(f"MTF [done]")

    elif (verbose == Verbosity.DETAIL):
      fig = pylab.gcf()
      fig.canvas.manager.set_window_title(f"MTF ({0:2.2f}% at Nyquist)".format(valueAtNyquist))
      (ax1) = plt.subplots(1)
      ax1.plot(interpDistances, interpValues)
      plt.show(block = False)
      plt.show()
    return cMTF(interpDistances, interpValues, valueAtNyquist, -1.0), cutoff_freq

  @staticmethod
  def MTF_Full(imgArr, fraction, verbose=Verbosity.NONE):
    imgArr = Transform.Orientify(imgArr)
    esf = MTF.GetESF_crop(imgArr, Verbosity.DETAIL)  # so you see raw ESF plot
    lsf = MTF.GetLSF(esf.interpESF, True, Verbosity.DETAIL)  # see LSF plot
    mtf, cutoff_freq = MTF.GetMTF(lsf, Verbosity.DETAIL)  # see MTF plot

    if (verbose == Verbosity.DETAIL):
        plt.figure(figsize=(8,6))  # new figure so it's not reusing gcf()
        x = [0, np.size(imgArr,1)-1]
        y = np.polyval(esf.edgePoly, x)

        gs = plt.GridSpec(3, 2)
        ax1 = plt.subplot(gs[0, 0])
        ax2 = plt.subplot(gs[1, 0])
        ax3 = plt.subplot(gs[2, 0])
        ax4 = plt.subplot(gs[:, 1])

        ax1.imshow(imgArr, cmap='gray', vmin=0.0, vmax=1.0)
        ax1.plot(x, y, color='red')
        ax1.axis('off')
        ax1.set_title(f"Original Image\nDimensions: {w} by {h}")
        ax2.plot(esf.rawESF.x, esf.rawESF.y,
                 esf.interpESF.x, esf.interpESF.y)
        top = np.max(esf.rawESF.y)-esf.threshold
        bot = np.min(esf.rawESF.y)+esf.threshold
        ax2.plot([esf.rawESF.x[0], esf.rawESF.x[-1]], [top, top], color='red')
        ax2.plot([esf.rawESF.x[0], esf.rawESF.x[-1]], [bot, bot], color='red')
        ax2.xaxis.set_visible(True)
        ax2.yaxis.set_visible(True)
        ax2.grid(True)
        ax2.minorticks_on()

        ax3.plot(lsf.x, lsf.y)
        ax3.xaxis.set_visible(True)
        ax3.yaxis.set_visible(True)
        ax3.grid(True)
        ax3.minorticks_on()

        ax4.plot(mtf.x, mtf.y)
        ax4.set_title(f"MTF{int(fraction*100)}: {cutoff_freq:0.2f}%\nMTF at Nyquist: {mtf.mtfAtNyquist:0.2f}%")
        ax4.plot(1.0, mtf.mtfAtNyquist/100, 'o', color='red', linestyle='None', label='Nyquist Frequency', ms=3)
        ax4.plot(cutoff_freq, fraction, 'o', color='red', linestyle='None', label=f'MTF{fraction*100} Frequency', ms=3)
        ax4.text(0.5, 0.99, f"Angle: {esf.angle:0.2f} degrees", ha='left', va='top')
        ax4.text(0.5, 0.94, f"Width: {esf.width:0.2f} pixels", ha='left', va='top')
        ax4.text(0.5, 0.89, f"Threshold: {esf.threshold:0.2f}", ha='left', va='top')
        ax4.set_xlabel('Normalized Frequency')
        ax4.set_ylabel('MTF Value')
        ax4.minorticks_on()

        plt.tight_layout()

        # Optional save to outputs/plots (or custom dir)
        if save_dir is not None:
            _out = Path(save_dir)
            _out.mkdir(parents=True, exist_ok=True)
            _stem = (filename or "mtf_output").rsplit('.', 1)[0]
            plt.savefig(_out / f"{_stem}_mtf.png", bbox_inches='tight', dpi=300)

        plt.show()
    return cMTF(mtf.x, mtf.y, mtf.mtfAtNyquist, esf.width)

# import os

# # Main working directory.
# images_folder = "\\Your own image folder name"
# dir = "Your own directory"
# os.chdir(dir + images_folder)
# print("Currently working in" + dir + images_folder)

# # Image processing for all in folder that ends with .png
# for i in os.listdir():
#   if i.endswith(".png"):
#     print("Processing image: " + i)
#     fraction = #your desired MTF. e.g. 0.5 for MTF50
#     filename=i.replace('.png', '_mtf.png')
#     img = Transform.LoadImg(i)
#     imgArr = Transform.Arrayify(img)
#     res = MTF.MTF_Full(imgArr, verbose=Verbosity.DETAIL)
#     plt.savefig(filename, bbox_inches='tight', dpi=300)
#     plt.close('all')

# # Saves all as an image with the same name as the original but with _mtf.png appended instead of .png
# # These also each are analyzed and saved in order of the original images, and in the same folder as the original images.

# print("All saved in current working directory: " + os.getcwd())



