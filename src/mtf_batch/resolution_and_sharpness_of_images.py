# -*- coding: utf-8 -*-
"""Resolution and Sharpness of Images

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dt-SLffFv1G7dlGy5o08Gmy8g_18ySrE

# Resolution and Sharpness of Images
From Damian Howe and Haarsha Krishna

## Formatting Data and Classes
"""

import matplotlib.pyplot as plt
import pylab as pylab
import numpy as np
import cv2 as cv2
import math as math

from PIL import Image, ImageOps
from scipy import interpolate
from scipy.fft import fft
from enum import Enum
from dataclasses import dataclass

@dataclass
class cSet:
  x: np.ndarray # storing indexes as a numpy array
  y: np.ndarray # storing values as a numpy array

@dataclass
class cESF:
  rawESF: cSet # raw ESF data as numpy arrays
  interpESF: cSet # interpolated ESF data as numpy arrays
  threshold: float # threshold used for ESF/MTF
  width: float # pixel transition size
  angle: float # slant angle (deg)
  edgePoly: np.ndarray # polynomial of slant

@dataclass
class cMTF:
  x: np.ndarray # array for indexes
  y: np.ndarray # array for values
  mtfAtNyquist: float # MTF value at sampling speed limit (Nyquist Freq)
  width: float # pixel transition size

@dataclass
class Verbosity(Enum): # output types/level of output
  NONE = 0 # none
  BRIEF = 1 # text
  DETAIL = 2 # graphical

"""## Image importing Functions"""

def _otsu_threshold01(gray):
  import numpy as _np
  g = _np.clip(gray, 0.0, 1.0)
  hist, bin_edges = _np.histogram(g.ravel(), bins=256, range=(0.0, 1.0))
  hist = hist.astype(float)
  prob = hist / (hist.sum() + 1e-12)
  omega = _np.cumsum(prob)
  centers = bin_edges[:-1] + (bin_edges[1]-bin_edges[0])/2.0
  mu = _np.cumsum(prob * centers)
  mu_t = mu[-1]
  sigma_b2 = (mu_t * omega - mu)**2 / (omega * (1.0 - omega) + 1e-12)
  idx = int(_np.nanargmax(sigma_b2))
  return float(bin_edges[idx])

def _michelson_contrast01(gray):
  import numpy as _np
  t = _otsu_threshold01(gray)
  dark = gray[gray <= t]
  bright = gray[gray > t]
  if dark.size < 5 or bright.size < 5:
    return 0.0
  Imin = float(dark.mean())
  Imax = float(bright.mean())
  denom = (Imax + Imin)
  return float((Imax - Imin) / denom) if denom != 0 else 0.0
    
class Transform:

  @staticmethod
  def LoadImg(file):
    img = Image.open(file)
    if img.mode in {'I;16','I;16L','I;16B','I;16N'}: # need correct format 16-bit unsigned integer pixel
        gsimg = img
    else:
        gsimg = img.convert('L') # converts to 8 bit pixels in greyscale
    return gsimg

  @staticmethod
  def Arrayify(img):
    if img.mode in {'I;16','I;16L','I;16B','I;16N'}:
      arr = np.asarray(img, dtype = np.double)/65535 # normalizing
    else:
      arr = np.asarray(img, dtype = np.double)/255 # also normalizing
    return arr # returns normalized array of img data

  @staticmethod
  def Imagify(Arr):
    img = Image.fromarray(Arr*255, mode='L')
    return img

  @staticmethod
  def Orientify(Arr):
    tl = np.average(Arr[0:2, 0:2])
    tr = np.average(Arr[0:2, -3:-1])
    bl = np.average(Arr[-3:-1, 0:2])
    br = np.average(Arr[-3:-1, -3:-1])

    corners = [tl, tr, bl, br]
    cornerIndexes = np.argsort(corners)

    if (cornerIndexes[0] + cornerIndexes[1]) == 1:
      pass
    elif(cornerIndexes[0] + cornerIndexes[1]) == 5:
      Arr = np.flip(Arr, axis=0)
    elif(cornerIndexes[0] + cornerIndexes[1]) == 2:
      Arr = np.transpose(Arr)
    elif(cornerIndexes[0] + cornerIndexes[1]) == 4:
      Arr = np.flip(np.transpose(Arr), axis=0)

    return Arr

"""## MTF Functions

"""

class MTF:
  # distances = microns/pixels away from the slant edge
  # values = array of brightnesses
  # head = top limit
  # tail = bottom limit
  @staticmethod
  def crop(values, distances, head, tail):
    isIncrementing = True
    if distances[0] > distances[-1]:
      isIncrementing = False
      distances = -distances
      dummy = -tail
      tail = -head
      head = dummy

    hindex = (np.where(distances < head)[0])
    tindex = (np.where(distances > tail)[0])

    if hindex.size < 2:
        h = 0
    else:
        h = np.amax(hindex)
    if tindex.size == 0:
        t = distances.size
    else:
        t = np.amin(tindex)

    if isIncrementing == False:
        distances = -distances

    return cSet(distances[h:t], values[h:t])

  @staticmethod
  def GetESF(Arr, edgePoly, verbose = Verbosity.NONE):
    Y = Arr.shape[0]
    X = Arr.shape[1]

    values = np.reshape(Arr, X*Y)

    distance = np.zeros((Y,X))
    column = np.arange(0,X) + 0.5
    for i in range(Y):
      distance[i,:] = (edgePoly[0]*column - (i+0.5) + edgePoly[1]) / np.sqrt(edgePoly[0]*edgePoly[0] + 1)

    distances = np.reshape(distance, X*Y)
    indexes = np.argsort(distances)

    sign = 1
    if np.average(values[indexes[:10]]) > np.average(values[indexes[-10:]]):
      sign = -1

    values = values[indexes]
    distances = sign*distances[indexes]

    if (distances[0] > distances[-1]):
      distances = np.flip(distances)
      values = np.flip(values)

    if (verbose == Verbosity.BRIEF):
      print(f"Raw ESF [done] (Distance from {0:2.2f} to {1:2.2f})".format(sign*distances[0], sign*distances[-1]))

    elif (verbose == Verbosity.DETAIL):
      x = [0, np.size(Arr,1)-1]
      y = np.polyval(edgePoly, x)

      fig = pylab.gcf()
      fig.canvas.manager.set_window_title('Raw ESF')
      (ax1, ax2) = plt.subplots(2)
      ax1.imshow(Arr, cmap = 'gray')
      ax1.plot(x, y, color = 'r')
      ax2.plot(distances, values)
      plt.show()
      plt.show(block = False)

    return cSet(distances, values)

  @staticmethod
  def GetESF_crop(Arr, verbose = Verbosity.NONE):
    imgArr = Transform.Orientify(Arr)
    edgeImg = cv2.Canny(np.uint8(imgArr*255), 40, 90, L2gradient = True)

    line = np.argwhere(edgeImg == 255)
    edgePoly = np.polyfit(line[:,1], line[:,0], 1)
    angle = math.degrees(math.atan(-edgePoly[0]))

    finalEdgePoly = edgePoly.copy()
    if angle>0:
      imgArr = np.flip(imgArr, axis = 1)
      finalEdgePoly[1] = np.polyval(edgePoly, np.size(imgArr, 1)-1)
      finalEdgePoly[0] = -edgePoly[0]

    esf = MTF.GetESF(imgArr, finalEdgePoly, Verbosity.BRIEF)

    esf_Values = esf.y
    esf_Distances = esf.x

    max = np.amax(esf_Values)
    min = np.amin(esf_Values)

    threshold = (max - min) * 0.1

    head = np.amax(esf_Distances[(np.where(esf_Values < min + threshold))[0]])
    tail = np.amin(esf_Distances[(np.where(esf_Values > max - threshold))[0]])

    width = abs(head-tail)

    esfRaw = MTF.crop(esf_Values, esf_Distances, head - 1.2*width, tail + 1.2*width)

    qs = np.linspace(0,1,20)[1:-1]
    knots = np.quantile(esfRaw.x, qs)
    tck = interpolate.splrep(esfRaw.x, esfRaw.y, t=knots, k=3)
    ysmooth = interpolate.splev(esfRaw.x, tck)

    InterpDistances = np.linspace(esfRaw.x[0], esfRaw.x[-1], 500)
    InterpValues = np.interp(InterpDistances, esfRaw.x, ysmooth)

    esfInterp = cSet(InterpDistances, InterpValues)

    if (verbose == Verbosity.BRIEF):
        print(f"ESF Crop [done] (Distance from {0:2.2f} to {1:2.2f})".format(esfRaw.x[0], esfRaw.x[-1]))

    elif (verbose == Verbosity.DETAIL):
        x = [0, np.size(imgArr,1)-1]
        y = np.polyval(finalEdgePoly, x)

        fig = pylab.gcf()
        fig.canvas.manager.set_window_title('ESF Crop')
        (ax1, ax2) = plt.subplots(2)
        ax1.imshow(imgArr, cmap='gray', vmin=0.0, vmax=1.0)
        ax1.plot(x, y, color='red')
        ax2.plot(esfRaw.x, esfRaw.y,InterpDistances,InterpValues)
        plt.show(block=False)
        plt.show()

    return cESF(esfRaw, esfInterp, threshold, width, angle, edgePoly)

  @staticmethod
  def Simplify_ESF(ESF, verbose=Verbosity.NONE):

    res = np.unique(ESF.x, return_index=True, return_counts=True)

    indexes = res[1]
    counts = res[2]
    sz = np.size(res[0])

    distances = ESF.x[indexes]
    values = np.zeros(sz, dtype=np.float64)

    for i in range(sz):
        values[i] = np.sum(ESF.y[indexes[i]:indexes[i]+counts[i]])/counts[i]

    if (verbose == Verbosity.BRIEF):
        print("ESF Simplification [done] (Size from {0:d} to {1:d})".format(np.size(ESF.x), np.size(distances)))

    elif (verbose == Verbosity.DETAIL):
        fig = pylab.gcf()
        fig.canvas.manager.set_window_title("ESF Simplification (Size from {0:d} to {1:d})".format(np.size(ESF.x), np.size(distances)))
        (ax1, ax2) = plt.subplots(2)
        ax1.plot(ESF.x, ESF.y)
        ax2.plot(distances, values)
        plt.show(block=False)
        plt.show()

    return cSet(distances, values)

  @staticmethod
  def GetLSF(ESF, normalize = True, verbose = Verbosity.NONE):
    lsfDividend = np.diff(ESF.y)
    lsfDivisor = np.diff(ESF.x)

    lsfValues = np.divide(lsfDividend, lsfDivisor)
    lsfDistances = ESF.x[0:-1]

    if normalize:
      lsfValues = lsfValues / (max(lsfValues))

    if (verbose == Verbosity.BRIEF):
      print(f"MTF [done]")

    elif (verbose == Verbosity.DETAIL):
      fig = pylab.gcf()
      fig.canvas.manager.set_window_title("LSF")
      (ax1) = plt.subplots(1)
      ax1.plot(lsfDistances, lsfValues)
      plt.show(block=False)
      plt.show()
    return cSet(lsfDistances, lsfValues)

  @staticmethod
  def GetMTF(LSF, verbose = Verbosity.NONE):
    N = np.size(LSF.x)
    px = N/(LSF.x[-1]- LSF.x[0])
    values = 1/np.sum(LSF.y)*abs(fft(LSF.y))
    distances = np.arange(0,N)/N*px

    interpDistances = np.linspace(0,1,50)
    interp = interpolate.interp1d(distances, values, kind='cubic')
    interpValues = interp(interpDistances)
    valueAtNyquist = interpValues[25]*100

    if (verbose == Verbosity.BRIEF):
      print(f"MTF [done]")

    elif (verbose == Verbosity.DETAIL):
      fig = pylab.gcf()
      fig.canvas.manager.set_window_title(f"MTF ({0:2.2f}% at Nyquist)".format(valueAtNyquist))
      (ax1) = plt.subplots(1)
      ax1.plot(interpDistances, interpValues)
      plt.show(block = False)
      plt.show()
    return cMTF(interpDistances, interpValues, valueAtNyquist, -1.0)

  @staticmethod
  def MTF_Full(imgArr, verbose=Verbosity.NONE, filename: str | None = None):
    raw_for_angle = imgArr.copy()
    orig_angle = _raw_edge_angle_deg(raw_for_angle)
    # Ensure canonical orientation for analysis
    imgArr = Transform.Orientify(imgArr)
    # Compute ESF/LSF/MTF
    esf = MTF.GetESF_crop(imgArr, Verbosity.BRIEF if verbose!=Verbosity.NONE else Verbosity.NONE)
    lsf = MTF.GetLSF(esf.interpESF, True, Verbosity.NONE)
    mtf = MTF.GetMTF(lsf, Verbosity.NONE)

    if (verbose == Verbosity.DETAIL):
        # Figure layout (similar to your reference with orientation/metadata)
        plt.figure(figsize=(10,7))

        x = [0, np.size(imgArr,1)-1]
        y = np.polyval(esf.edgePoly, x)

        gs = plt.GridSpec(3, 2, width_ratios=[1.1, 1.4])
        ax1 = plt.subplot(gs[0, 0])   # ROI
        ax2 = plt.subplot(gs[1, 0])   # Edge profile (ESF)
        ax3 = plt.subplot(gs[2, 0])   # LSF
        ax4 = plt.subplot(gs[:, 1])   # MTF + info panel

        # Subplot: ROI/Image with detected edge overlay
        ax1.imshow(imgArr, cmap='gray', vmin=0.0, vmax=1.0)
        ax1.plot(x, y, color='red', linewidth=1.25)
        ax1.set_title("ROI / Image")
        ax1.axis('off')

        # Subplot: Edge profile (raw + interpolated)
        ax2.plot(esf.rawESF.x, esf.rawESF.y, label="Raw ESF")
        ax2.plot(esf.interpESF.x, esf.interpESF.y, label="Smoothed ESF")
        top = np.max(esf.rawESF.y)-esf.threshold
        bot = np.min(esf.rawESF.y)+esf.threshold
        ax2.plot([esf.rawESF.x[0], esf.rawESF.x[-1]], [top, top], color='red', linewidth=1.0)
        ax2.plot([esf.rawESF.x[0], esf.rawESF.x[-1]], [bot, bot], color='red', linewidth=1.0)
        ax2.set_title("Edge profile: Vertical")
        ax2.set_xlabel("Distance (pixels)")
        ax2.set_ylabel("Edge profile (linear)")
        ax2.grid(True, alpha=0.3)
        ax2.legend(loc="lower right", fontsize=8)

        # Subplot: LSF
        ax3.plot(lsf.x, lsf.y)
        ax3.set_xlabel("Distance (pixels)")
        ax3.set_ylabel("LSF (normalized)")
        ax3.grid(True, alpha=0.3)

        # Subplot: MTF with Nyquist line + info box
        ax4.plot(mtf.x, mtf.y, linewidth=1.5)
        ax4.axvline(0.5, linestyle="--", linewidth=1.0)  # Nyquist at 0.5 cyc/pix
        ax4.set_xlim(0.0, 1.0)
        ax4.set_ylim(0.0, 1.05)
        ax4.set_xlabel("Frequency, Cycles/pixel")
        ax4.set_ylabel("MTF")
        ax4.set_title(f"MTF at Nyquist: {mtf.mtfAtNyquist:0.2f}%")
        ax4.grid(True, alpha=0.3)

        # Orientation + contrast + dims info
        H, W = imgArr.shape[:2]
        contrast = _michelson_contrast01(imgArr)
        info = (
            f"Original edge angle: {orig_angle:.2f}°\n"
            f"Normalized edge angle: {esf.angle:.2f}°\n"
            f"Est. chart contrast: {contrast*100:.1f}%\n"
            f"Image width: {W} px\n"
            f"Image height: {H} px\n"
            f"Transition width: {esf.width:.2f} px\n"
            f"Threshold: {esf.threshold:.2f}"
        )
        ax4.text(0.62, 0.75, info, transform=ax4.transAxes, ha='left', va='top')

        if filename:
            plt.suptitle(filename, y=0.98)

        plt.tight_layout()
        plt.show()

    return cMTF(mtf.x, mtf.y, mtf.mtfAtNyquist, esf.width)
      
def _raw_edge_angle_deg(arr01):
  
  import numpy as _np, cv2 as _cv2, math as _math
  a = _np.asarray(arr01, dtype=float)
  if a.max() > 1.0:  # normalize if not already 0..1
    a = a / 255.0
  a = _np.squeeze(a)
  if a.ndim == 3 and a.shape[2] >= 3:
    # luminance
    a = 0.2126*a[...,0] + 0.7152*a[...,1] + 0.0722*a[...,2]
  edgeImg = _cv2.Canny(_np.uint8(_np.clip(a,0,1)*255), 40, 90, L2gradient=True)
  line = _np.argwhere(edgeImg == 255)
  if line.size < 2:
    return 0.0
  edgePoly = _np.polyfit(line[:,1], line[:,0], 1)
  angle = _math.degrees(_math.atan(-edgePoly[0]))
  return float(angle)


import os

# Main working directory.
images_folder = "\\Your own image folder name"
dir = "Your own directory"
os.chdir(dir + images_folder)
print("Currently working in" + dir + images_folder)

# Image processing for all in folder that ends with .png
for i in os.listdir():
  if i.endswith(".png"):
    print("Processing image: " + i)
    filename=i.replace('.png', '_mtf.png')
    img = Transform.LoadImg(i)
    imgArr = Transform.Arrayify(img)
    res = MTF.MTF_Full(imgArr, verbose=Verbosity.DETAIL)
    plt.savefig(filename, bbox_inches='tight', dpi=300)
    plt.close('all')

# Saves all as an image with the same name as the original but with _mtf.png appended instead of .png
# These also each are analyzed and saved in order of the original images, and in the same folder as the original images.

print("All saved in current working directory: " + os.getcwd())

